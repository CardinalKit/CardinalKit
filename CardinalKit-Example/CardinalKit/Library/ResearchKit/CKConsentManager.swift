//
//  CKConsentManager.swift
//  CardinalKit_Example
//
//  Created by Vishnu Ravi on 1/5/23.
//  Copyright Â© 2023 CardinalKit. All rights reserved.
//

import Firebase
import ResearchKit

enum CKConsentError: Error {
    case urlError
    case saveError
    case uploadError
    case downloadError
}

class CKConsentManager {
    private var storageRef: StorageReference

    private var consentFileName: String = {
        let config = CKPropertyReader(file: "CKConfiguration")
        return config.read(query: "Consent File Name") ?? "My Consent File"
    }()

    /// Create a consent file manager
    /// - Parameter storageRef: Reference to Firebase Cloud Storage
    init(storageRef: StorageReference = Storage.storage().reference()) {
        self.storageRef = storageRef
    }

    /// Uploads a consent PDF file to Firebase Cloud Storage
    /// - Parameter data: PDF data generated by ResearchKit after user signs the consent form. See `ConsentDocument`.
    func uploadConsent(data: Data) async throws {
        var docURL = (FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)).first
        docURL = docURL?.appendingPathComponent("\(consentFileName).pdf")

        guard let url = docURL,
              let documentCollection = CKStudyUser.shared.authCollection else {
            throw CKConsentError.urlError
        }

        // Saves the PDF to a file locally and sets its location in User Defaults
        do {
            try data.write(to: url)
            UserDefaults.standard.set(url.path, forKey: "consentFormURL")
        } catch {
            throw CKConsentError.saveError
        }

        // Uploads the PDF file to Firebase Cloud Storage
        let documentRef = storageRef.child("\(documentCollection)/\(consentFileName).pdf")
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            documentRef.putFile(from: url, metadata: nil) { _, error in
                if error != nil {
                    continuation.resume(throwing: CKConsentError.uploadError)
                } else {
                    continuation.resume()
                }
            }
        }
    }

    /// Downloads the user's consent PDF from Firebase Cloud Storage
    /// - Returns: the local URL of the downloaded PDF file
    func downloadConsent() async throws -> URL {
        guard let documentCollection = CKStudyUser.shared.authCollection else {
            throw CKConsentError.urlError
        }

        let documentRef = storageRef.child("\(documentCollection)/\(consentFileName).pdf")

        guard let docURL = (FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)).first else {
            throw CKConsentError.urlError
        }

        // Download the PDF file from Firebase Cloud Storage and save it locally
        let url = docURL.appendingPathComponent("\(consentFileName).pdf")
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            documentRef.write(toFile: url) { _, error in
                if error != nil {
                    continuation.resume(throwing: CKConsentError.downloadError)
                } else {
                    UserDefaults.standard.set(url.path, forKey: "consentFormURL")
                    continuation.resume()
                }
            }
        }
        return url
    }

    /// Verifies that a user has a consent file in Cloud Storage
    /// - Returns: a boolean representing whether the presence of the consent file could be verified
    func verifyConsent() async -> Bool {
        guard let documentCollection = CKStudyUser.shared.authCollection else {
            return false
        }

        let documentRef = storageRef.child("\(documentCollection)/\(consentFileName).pdf")

        return await withCheckedContinuation { (continuation: CheckedContinuation) in
            documentRef.getMetadata { metadata, error in
                if error != nil {
                    continuation.resume(returning: false)
                } else {
                    continuation.resume(returning: true)
                }
            }
        }
    }
}
